# 领域驱动设计
用演进式的领域模型将软件设计与实现连接起来，用来满足复杂领域的软件开发方法。

## 领域模型
- 面向复杂领域
- 模型能将设计和实现衔接
- 模型是演进的

一个模型达成共识；不再有分析模型、设计模型等；

## 领域驱动设计过程
1. 分析师、设计师、主要程序员参与模型设计；
2. 只针对核心资产使用统一的领域模型()；非核心资产可以差别的模型或无模型？

## 战略设计
- 识别业务核心域；按核心域、支撑域、通用域切分，核心域才是DDD应该关注的地方。
- 分离关注点；以Bounded Context为边界划分模型；？？？？

- 模型集成策略；

核心域--》BC，对BC建模--》Domain

## 战术设计
##### 建模元素
- Entity(实体)
- Value Object(值对象)
- Aggregate
- Factory
- Repository
- Service
- Event

## DDD读书笔记
DDD中，三个基本用途决定了模型的选择：
1. 模型和设计的核心相互影响；
2. 模型是团队所有成员所使用的交流语言的中枢；
3. 模型是浓缩的知识；

### Ch1：消化知识(浏览)
##### 1.1 有效建模的要素
通过作者与PCB工程师共同建模的故事，提炼出建模案例成功的要素：
- 模型和实现绑定(一致)；
- 统一到基于模型的语言；(团队成员、开发人员和领域业务专家使用一种公共的建模语言)
- 开发一个蕴含丰富知识的模型；
- 提炼模型；(去粗取精，类似前言的中国地图)
- 头脑风暴和实验；(校对模型)

##### 1.2 知识消化
知识消化，一般是在开发人员的领导下，由开发人员与领域专家组成的团队来共同协作。

强调了不能按照业务专家-->分析师-->程序员的单向、单次反馈，与WB课程所提一致；

##### 1.3 持续学习
##### 1.4 知识丰富的设计
通过航船超额订货单示例讲述了好的模型设计有助于突出重点项，能让业务专家和程序员都能明显找到超额订货策略。
##### 1.5 深层模型
随着对领域和应用需求的理解逐步加深，模型中原本表面看起来重要的元素可能会被移除；开始时不被发现的抽象可能会成为问题要害。

要想建立实用且清晰的模型，团队成员需持续学习，既要精通领域业务知识，也要精通建模技术。

### Ch2：语言的交流和使用(浏览)
##### 2.1 模式：Ubiquitous language(通用语言)
语言不统一会造成相互理解错误、概念混淆等；引入翻译使得沟通不畅，导致知识消化变得困难；

领域模型可以成为公共语言的核心；Ubiquitous language的词汇表包含**类名称**和**主要操作**;

“知识消化过程”依赖“基于模型的语言的使用”。

![ubiquitous_lang](p40)

通过相似的两段对货运建模的示例说明通用语言在交流中所起的积极作用。

##### 2.2 “大声地”建模
![exampl，对比的示例](p43)
讨论系统时要结合模型。使用模型的元素以及模型中各元素之间的交互来大声描述场景，并且按照模型允许的方式将各种概念结合到一起。找到更简单的表达方式来讲出你要讲的话，然后将这些新的思想应用到图和代码中。

##### 2.3 一个团队，一种语言
![jiaoji](图2-3)

##### 2.4 文档和图
作者画图以UML中的类图和对象交互图(或序列图)为主；但UML图无法传达模型的两个最重要的方面：一是模型所表示的概念的意义，另一方面是对象应该做哪些事情。

应避免使用包罗万象的对象模型图，甚至不能使用包含所有细节的UML数据存储库。应使用简化的图，图中只包含对象模型的重要概念部分，这些部分对于理解设计至关重要。

设计的重要细节应该在代码中体现出来。通常的用法是以图为主，辅以文本注释。作者更愿意以文本为主，添加精心挑战的简化图作为注释。

务必要记住*模型不是图*。图的目的是帮助表达和解释模型。代码可以充当设计细节的存储库。

###### 2.4.1 书面设计文档
- 文档应作为代码和口头交流的补充。
> - 极限编程不主张使用过多的设计文档，而是让代码解释它自己(因为注释和文档都可能出现于实际运行代码的不同步)。但作者指出，完全将代码作为一种设计文档也存在的局限性：会把读代码的人淹没在细节中；且开发人员并不是唯一需要理解模型的人。
> - 文档不应再重复表示代码已经明确表达出的内容。文档应将注意力集中在核心元素上，当代码无法直接明了地实现概念时，文档可以澄清设计意图。

- 文档应努力寻求生存之道并保持最新
> - 文档必须深入到各种项目活动中去。 判断方法：观察文档与Ubiquitous language之间的交互。
> - 通过将文档减至最少，并且主要用它来补充代码和口头交流，就可以避免文档与项目脱节。

###### 2.4.2 完全依赖可执行代码的情况
XP社区几乎完全依赖可执行代码和代码测试。但依赖开发人员的自律。

##### 2.5 解释性模型
核心思想是在实现、设计和团队交流中使用同一个模型作为基础。但为了学习领域，还可以引入其它视图，这些视图仅用作传递一般领域知识的教学工具。

解释性模型可用于澄清范围伤受到严格限制的技术模型。**解释性模型最好不是对象模型，可避免人们错误地认为这些模型与软件设计是一致的**。

![示例](图2-4及图2-5)

### Ch3：绑定模型和实现
##### 3.1 模式：Model-Driven Design

##### 3.2 建模范式和工具支持

##### 3.3 揭示主旨：为什么模型对用户至关重要

##### 3.4 模式：Hands-on Modeler


### Ch4：分离领域


周日：Ch2~4，5~6
周一：Ch7、14；外链1、2
周二：外3，总结；sprint1框架

## 参考
1. [领域驱动设计到底难在哪？](https://www.jianshu.com/p/ab80cb9f307c)
2. [“领域驱动设计”答疑（汇总）](https://www.jianshu.com/p/f876d19a9aa3)
3. [DCI in C++](https://www.jianshu.com/p/bb9c35606d29)
4. Domain-Driven Design, Trakling Complexity in the Heart of Software; by Eric Evans.

# 面向模型的实现模式(C语言的实现)
### 表达概念
##### 1 命名
命名同时表达领域语义与**模型角色**(如xxService，xxRepo)；

Modular C可采用类似C++类的方法，不要一个文件塞太多东西，避免xxFunc, xxCommon这种无意义的命名；
推荐每个概念按照C++类的实现，放一个专有.c和对应的.h。

##### 2 行为
- 突出对外API，最小化暴露；(头文件显式定义API，只放API依赖的元素)
- 让接口有领域含义，尽量不要有get/set([Tell Don't Ask原则](https://www.aqee.net/post/tell-dont-ask.html)，尽量不感知调用对象内部状态)；(不要为了私有变量做get/set)
- 区分set(update)和构造的服务上下文区别；？？
- **通过包含接口类型，显式化声明接口；(派生行为，即例中的setup_handle函数指针)**

公有行为：提供一个可直接调用的接口函数；
私有行为：隐藏在自己的.c中；
通过派生得到接口的行为：C语言结构体中嵌入函数指针；

##### 3 属性
- 明确区分**属性**和**依赖**

Value Object(值对象)建议用const修饰。

### 表达关系
可参考UML类图中的[6大关系](uml.md)
- is-a：泛化关系，派生或继承；C语言用函数指针表示is-a，区分有状态和无状态；
  > - 使用函数指针结构体表示抽象接口；
  > - 无状态和有状态，有状态的情况需传递状态；
  > - 使用`void*`指针传递不同的状态类型；
  > - 使用表描述一组共同变化的函数指针； 
- has-a：组合&聚合；
  > - Composition: 优先推荐值包含；
  > - Aggregation: 使用指针；用const表示不可更改；
- has-many：
  > - 根据目标需要，实现选择合适的依赖方向； 
- dependency：
  > - 参数依赖，use关系，传递指针类型，const修饰；
  > - 返回值依赖，create关系，一般返回指针类型
  > - 减少dependency的物理依赖，尽量前置声明，不要在头文件中包含依赖的头文件；

### 生命周期管理？？？（目的是什么？）

C语言用factory和repository隐藏内存预占的全局变量；

- 全局变量没有生命周期的语义，区分内存预占和生命周期管理；
- C语言没有构造和析构，生命周期管理显式的使用Factory(如示例中port_factory.c中的alloc和release函数)；
- 用Factory隐藏内存预占的全局变量，明确对外提供生命周期语义；
- 嵌入式场景下，Factory和Repository很多情况可以合一；
- 编译器拓展，实现全局自动注册的能力，区分类型与对象的生命周期；


### 物理设计
保持逻辑结构和物理结构的一致性；

##### 1 符号隐藏
- 使用static关键字隐藏私有方法（Modular C中的PRIVATE实际为static）；
- 使用编译器拓展隐藏包内接口；
##### 2 文件组织
- 头文件结构
- API访问级别：包内、包外、私有；
- 接口参数格式，显式的this，const；
- Modular C风格，一个.h和.c表示一个概念；
- **前置声明**，可避免将仅内部使用的结构体开放到头文件中！！参考C++的[PImpl](https://en.cppreference.com/w/cpp/language/pimpl)技术；
> - 编译时弱依赖的指针、返回值类型、函数参数类型等都可做前置声明；
##### 3 文件夹(包)组织
*问题： 一个组件中的so有没有数量限制，6~7个so是不是太多？ 1个so是否合适？*
