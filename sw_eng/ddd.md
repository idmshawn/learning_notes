# 领域驱动设计

### 领域模型
- 面向复杂领域
- 模型能将设计和实现衔接
- 模型是演进的

一个模型达成共识；不再有分析模型、设计模型等；

### 领域驱动设计过程
1. 分析师、设计师、主要程序员参与模型设计；
2. 只针对核心资产使用统一的领域模型()；非核心资产可以差别的模型或无模型？

### 战略设计
- 识别业务核心域；按核心域、支撑域、通用域切分，核心域才是DDD应该关注的地方。
- 分离关注点；以Bounded Context为边界划分模型；？？？？

- 模型集成策略；

核心域--》BC，对BC建模--》Domain

### 战术设计
##### 建模元素
- Entity(实体)
- Value Object(值对象)
- Aggregate
- Factory
- Repository
- Service
- Event

### 面向模型的实现模式(C语言的实现)
##### 表达概念
###### 1 命名
命名同时表达领域语义与**模型角色**(如xxService，xxRepo)；

Modular C可采用类似C++类的方法，不要一个文件塞太多东西，避免xxFunc, xxCommon这种无意义的命名；
推荐每个概念按照C++类的实现，放一个专有.c和对应的.h。

###### 2 行为
- 突出对外API，最小化暴露；(头文件显式定义API，只放API依赖的元素)
- 让接口有领域含义，尽量不要有get/set([Tell Don't Ask原则](https://www.aqee.net/post/tell-dont-ask.html)，尽量不感知调用对象内部状态)；
- 区分set(update)和构造的服务上下文区别；？？
- **通过包含接口类型，显式化声明接口；(派生行为，即例中的setup_handle函数指针)**

公有行为：提供一个可直接调用的接口函数；
私有行为：隐藏在自己的.c中；
通过派生得到接口的行为：C语言结构体中嵌入函数指针；

###### 3 属性
- 明确区分**属性**和**依赖**

Value Object(值对象)建议用const修饰。

##### 表达关系
可参考UML类图中的6大关系
- is-a：泛化关系，派生或继承；C语言用函数指针表示is-a，区分有状态和无状态；
  > - 使用函数指针结构体表示抽象接口；
  > - 无状态和有状态，有状态的情况需传递状态；
  > - 使用`void*`指针传递不同的状态类型；
  > - 使用表描述一组共同变化的函数指针； 
- has-a：组合&聚合；
  > - Composition: 优先推荐值包含；
  > - Aggregation: 使用指针；用const表示不可更改；
- has-many：
  > - 根据目标需要，实现选择合适的依赖方向； 
- dependency：
  > - 参数依赖，use关系，传递指针类型，const修饰；
  > - 返回值依赖，create关系，一般返回指针类型
  > - 减少dependency的物理依赖，尽量前置声明，不要在头文件中包含依赖的头文件；

##### 生命周期管理
C语言用factory和repository隐藏内存预占的全局变量；

##### 物理设计
保持逻辑结构和物理结构的一致性；
Modular C风格，一个.h和.c表示一个概念；


