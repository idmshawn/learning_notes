
# DDD读书笔记
DDD中，三个基本用途决定了模型的选择：
1. 模型和设计的核心相互影响；
2. 模型是团队所有成员所使用的交流语言的中枢；
3. 模型是浓缩的知识；

## Ch1：消化知识(浏览)
#### 1.1 有效建模的要素
通过作者与PCB工程师共同建模的故事，提炼出建模案例成功的要素：
- 模型和实现绑定(一致)；
- 统一到基于模型的语言；(团队成员、开发人员和领域业务专家使用一种公共的建模语言)
- 开发一个蕴含丰富知识的模型；
- 提炼模型；(去粗取精，类似前言的中国地图)
- 头脑风暴和实验；(校对模型)

#### 1.2 知识消化
知识消化，一般是在开发人员的领导下，由开发人员与领域专家组成的团队来共同协作。

强调了不能按照业务专家-->分析师-->程序员的单向、单次反馈，与WB课程所提一致；

#### 1.3 持续学习
#### 1.4 知识丰富的设计
通过航船超额订货单示例讲述了好的模型设计有助于突出重点项，能让业务专家和程序员都能明显找到超额订货策略。
#### 1.5 深层模型
随着对领域和应用需求的理解逐步加深，模型中原本表面看起来重要的元素可能会被移除；开始时不被发现的抽象可能会成为问题要害。

要想建立实用且清晰的模型，团队成员需持续学习，既要精通领域业务知识，也要精通建模技术。

## Ch2：语言的交流和使用(浏览)
#### 2.1 模式：Ubiquitous language(通用语言)
语言不统一会造成相互理解错误、概念混淆等；引入翻译使得沟通不畅，导致知识消化变得困难；

领域模型可以成为公共语言的核心；Ubiquitous language的词汇表包含**类名称**和**主要操作**;

“知识消化过程”依赖“基于模型的语言的使用”。

![ubiquitous_lang](p40)

通过相似的两段对货运建模的示例说明通用语言在交流中所起的积极作用。

#### 2.2 “大声地”建模
![exampl，对比的示例](p43)
讨论系统时要结合模型。使用模型的元素以及模型中各元素之间的交互来大声描述场景，并且按照模型允许的方式将各种概念结合到一起。找到更简单的表达方式来讲出你要讲的话，然后将这些新的思想应用到图和代码中。

#### 2.3 一个团队，一种语言
![jiaoji](图2-3)

#### 2.4 文档和图
作者画图以UML中的类图和对象交互图(或序列图)为主；但UML图无法传达模型的两个最重要的方面：一是模型所表示的概念的意义，另一方面是对象应该做哪些事情。

应避免使用包罗万象的对象模型图，甚至不能使用包含所有细节的UML数据存储库。应使用简化的图，图中只包含对象模型的重要概念部分，这些部分对于理解设计至关重要。

设计的重要细节应该在代码中体现出来。通常的用法是以图为主，辅以文本注释。作者更愿意以文本为主，添加精心挑战的简化图作为注释。

务必要记住*模型不是图*。图的目的是帮助表达和解释模型。代码可以充当设计细节的存储库。

##### 2.4.1 书面设计文档
- 文档应作为代码和口头交流的补充。
> - 极限编程不主张使用过多的设计文档，而是让代码解释它自己(因为注释和文档都可能出现于实际运行代码的不同步)。但作者指出，完全将代码作为一种设计文档也存在的局限性：会把读代码的人淹没在细节中；且开发人员并不是唯一需要理解模型的人。
> - 文档不应再重复表示代码已经明确表达出的内容。文档应将注意力集中在核心元素上，当代码无法直接明了地实现概念时，文档可以澄清设计意图。

- 文档应努力寻求生存之道并保持最新
> - 文档必须深入到各种项目活动中去。 判断方法：观察文档与Ubiquitous language之间的交互。
> - 通过将文档减至最少，并且主要用它来补充代码和口头交流，就可以避免文档与项目脱节。

##### 2.4.2 完全依赖可执行代码的情况
XP社区几乎完全依赖可执行代码和代码测试。但依赖开发人员的自律。

#### 2.5 解释性模型
核心思想是在实现、设计和团队交流中使用同一个模型作为基础。但为了学习领域，还可以引入其它视图，这些视图仅用作传递一般领域知识的教学工具。

解释性模型可用于澄清范围伤受到严格限制的技术模型。**解释性模型最好不是对象模型，可避免人们错误地认为这些模型与软件设计是一致的**。

![示例](图2-4及图2-5)

## Ch3：绑定模型和实现
#### 3.1 模式：Model-Driven Design

#### 3.2 建模范式和工具支持

#### 3.3 揭示主旨：为什么模型对用户至关重要

#### 3.4 模式：Hands-on Modeler


## Ch4：分离领域


周日：Ch2~4，5~6
周一：Ch7、14；外链1、2
周二：外3，总结；sprint1框架

## 参考
1. Domain-Driven Design, Trakling Complexity in the Heart of Software; by Eric Evans.
2. [领域驱动设计到底难在哪？](https://www.jianshu.com/p/ab80cb9f307c)
3. [“领域驱动设计”答疑（汇总）](https://www.jianshu.com/p/f876d19a9aa3)
4. [DCI in C++](https://www.jianshu.com/p/bb9c35606d29)
