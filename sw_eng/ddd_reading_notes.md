
# DDD读书笔记
DDD中，三个基本用途决定了模型的选择：
1. 模型和设计的核心相互影响；
2. 模型是团队所有成员所使用的交流语言的中枢；
3. 模型是浓缩的知识；

书中Ch1~3浏览即可，Chxx需要精读？

## Ch1：消化知识
### 1.1 有效建模的要素
通过作者与PCB工程师共同建模的故事，提炼出建模案例成功的要素：
- 模型和实现绑定(一致)；
- 统一到基于模型的语言；(团队成员、开发人员和领域业务专家使用一种公共的建模语言)
- 开发一个蕴含丰富知识的模型；
- 提炼模型；(去粗取精，类似前言的中国地图)
- 头脑风暴和实验；(校对模型)

### 1.2 知识消化
知识消化，一般是在开发人员的领导下，由开发人员与领域专家组成的团队来共同协作。

强调了不能按照业务专家-->分析师-->程序员的单向、单次反馈，与WB课程所提一致；

### 1.3 持续学习
### 1.4 知识丰富的设计
通过航船超额订货单示例讲述了好的模型设计有助于突出重点项，能让业务专家和程序员都能明显找到超额订货策略。
### 1.5 深层模型
随着对领域和应用需求的理解逐步加深，模型中原本表面看起来重要的元素可能会被移除；开始时不被发现的抽象可能会成为问题要害。

要想建立实用且清晰的模型，团队成员需持续学习，既要精通领域业务知识，也要精通建模技术。

## Ch2：语言的交流和使用
### 2.1 模式：Ubiquitous language(通用语言)
语言不统一会造成相互理解错误、概念混淆等；引入翻译使得沟通不畅，导致知识消化变得困难；

领域模型可以成为公共语言的核心；Ubiquitous language的词汇表包含**类名称**和**主要操作**;

“知识消化过程”依赖“基于模型的语言的使用”。

![ubiquitous_lang](p40)

通过相似的两段对货运建模的示例说明通用语言在交流中所起的积极作用。

### 2.2 “大声地”建模
![exampl，对比的示例](p43)
讨论系统时要结合模型。使用模型的元素以及模型中各元素之间的交互来大声描述场景，并且按照模型允许的方式将各种概念结合到一起。找到更简单的表达方式来讲出你要讲的话，然后将这些新的思想应用到图和代码中。

### 2.3 一个团队，一种语言
![jiaoji](图2-3)

### 2.4 文档和图
作者画图以UML中的类图和对象交互图(或序列图)为主；但UML图无法传达模型的两个最重要的方面：一是模型所表示的概念的意义，另一方面是对象应该做哪些事情。

应避免使用包罗万象的对象模型图，甚至不能使用包含所有细节的UML数据存储库。应使用简化的图，图中只包含对象模型的重要概念部分，这些部分对于理解设计至关重要。

设计的重要细节应该在代码中体现出来。通常的用法是以图为主，辅以文本注释。作者更愿意以文本为主，添加精心挑战的简化图作为注释。

务必要记住*模型不是图*。图的目的是帮助表达和解释模型。代码可以充当设计细节的存储库。

#### 2.4.1 书面设计文档
- 文档应作为代码和口头交流的补充。
> - 极限编程不主张使用过多的设计文档，而是让代码解释它自己(因为注释和文档都可能出现于实际运行代码的不同步)。但作者指出，完全将代码作为一种设计文档也存在的局限性：会把读代码的人淹没在细节中；且开发人员并不是唯一需要理解模型的人。
> - 文档不应再重复表示代码已经明确表达出的内容。文档应将注意力集中在核心元素上，当代码无法直接明了地实现概念时，文档可以澄清设计意图。

- 文档应努力寻求生存之道并保持最新
> - 文档必须深入到各种项目活动中去。 判断方法：观察文档与Ubiquitous language之间的交互。
> - 通过将文档减至最少，并且主要用它来补充代码和口头交流，就可以避免文档与项目脱节。

#### 2.4.2 完全依赖可执行代码的情况
XP社区几乎完全依赖可执行代码和代码测试。但依赖开发人员的自律。

### 2.5 解释性模型
核心思想是在实现、设计和团队交流中使用同一个模型作为基础。但为了学习领域，还可以引入其它视图，这些视图仅用作传递一般领域知识的教学工具。

解释性模型可用于澄清范围伤受到严格限制的技术模型。**解释性模型最好不是对象模型，可避免人们错误地认为这些模型与软件设计是一致的**。

![示例](图2-4及图2-5)

## Ch3：绑定模型和实现
领域驱动设计要求模型不仅能够指导早期的分析工作，还应该成为设计的基础。

### 3.1 模式：Model-Driven Design
严格按照基础模型来编写代码，能够使代码更好地表达设计含义，并且使模型更符合设计。

Model-Driven Design不再将分析模型(目的是对领域进行抽象)和程序设计(目的是解决应用程序的问题)分离开，而是寻求一种能够满足这两方面需求的单一模型。MDD绑定了模型和程序设计。
- 如果模型对于程序的实现来说显得不太实用时，必须重新设计它；
- 如果模型无法忠实地描述领域的关键概念，也必须重新设计它；
这样，建模和程序设计就结合为一个统一的迭代开发过程。

### 3.2 建模范式和工具支持
过程语言(C语言)没有适用的建模范式，并不适用于Model-Driven Design。

**面向对象设计**是目前大多数大型项目所使用的建模范式，也是本书使用的主要方法。

PCB布线中net元素的示例：
- 用类图完成了一个简化的领域建模；
- 依照模型写出了java代码，Abstract Net父类，和Net子类，及其方法；
- Serveice和Repository都可以进行单元测试，给出了基于JUnit的测试框架；

据上例得出Model-Driven Design的好处：
- 易于拓展：能够为规则的组合设置限制条件，还能提供其他的一些增强功能；
- 方便测试：组件都具有定义完善的接口，可进行单元测试。

设计不是一蹴而就的，需要反复研究领域知识，不断重构模型，才能将领域中重要的概念提炼成简单而清晰的模型。

### 3.3 揭示主旨：为什么模型对用户至关重要
通过IE浏览器收藏夹不支持非法字符的例子，说明模型对用户的作用。

### 3.4 模式：Hands-on Modeler
将分析、建模、设计和编程工作完全分离会对Model-Driven Design产生不良影响。

作者参与项目的反面例子，建模人员不被允许参与代码实现，两部分完全脱钩；
模型没有派上用场，原因：
1. 将模型传递给开发人员的过程中，模型中的一些意图并没有向他们说明；
2. 模型与程序实现及技术相互影响，而我无法直接获得这种反馈。

Model-Driven Design的两个基本要素：**模型要支持有效的实现**并**抽象出关键的领域知识**；
总结：P62中间黑体字。

## Ch4：分离领域

### 4.1 模式：Layered Architecture

### 4.2 模型属于领域层

### 4.3 模式：The Smart UI “Anti-Pattern”

### 4.4 其它分离方式

## Ch5：软件中所表示的模型


## 书中提到的设计模式
- 策略模式(strategy)：p36，ch1.4
- 外观模式(facade)：p59，ch3.2 

周日：Ch2~4，5~6
周一：Ch7、14；外链1、2
周二：外3，总结；sprint1框架

## 参考
1. Domain-Driven Design, Trakling Complexity in the Heart of Software; by Eric Evans.
2. [领域驱动设计到底难在哪？](https://www.jianshu.com/p/ab80cb9f307c)
3. [“领域驱动设计”答疑（汇总）](https://www.jianshu.com/p/f876d19a9aa3)
4. [DCI in C++](https://www.jianshu.com/p/bb9c35606d29)
